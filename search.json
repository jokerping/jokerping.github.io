[{"title":"go语言学习心得","url":"/2021/05/19/goLang/","content":"\n\n# 序\n在看go的过程中发现了一些比较有意思的点，在swift中是没有的，记一下省的以后找。一些几乎所有语言通用的做法就不写了。目前看的是[the-way-to-go_ZH_CN](https://github.com/unknwon/the-way-to-go_ZH_CN)翻译的还算OK。本文标题也按照书中章节来，但并不是每章都会写。\n\n\n\n# 基本结构和基本数据类型\n1、括号必须和方法一行，声明的局部变量必须使用，引入的包必须使用，否则就给你报错。这点我觉得非常好，让那些异端闭嘴。\n\n2、首字母大写就public 小写就private 非常方便\n\n3、:= 简短声明，在方法内部可以直接这样声明一个新变量d，\b比较省事 `a := 1`\n\n4、声明枚举的时候可以用个常量 `const` ，我看标准库中的枚举会type 一个名字，这样做用来标记个枚举？`iota` 这个关键字比较麻烦，我就不解释了，查一下非常方便。\n> 实际上，类型别名得到的新类型并非和原类型完全相同，新类型不会拥有原类型所附带的方法\n\n```go\ntype Color int\nconst(\n    RED Color = iota\n    YELLOW\n)\n```\n\n5、时间格式化。这简直神经病，不用Y-m-d H:M:S 也就算了，传时间也不是随便传的要用go语言创建时间(2006-01-02 15:04:05 -0700 MST)格式化，比如：\n`time.Now().Format(\"2006-01-02 15:04:05\")`\n当然标准库里定义了一堆常用的\n```go\nconst (\n   ANSIC       = \"Mon Jan _2 15:04:05 2006\"\n   UnixDate    = \"Mon Jan _2 15:04:05 MST 2006\"\n   RubyDate    = \"Mon Jan 02 15:04:05 -0700 2006\"\n   RFC822      = \"02 Jan 06 15:04 MST\"\n   RFC822Z     = \"02 Jan 06 15:04 -0700\" // RFC822 with numeric zone\n   RFC850      = \"Monday, 02-Jan-06 15:04:05 MST\"\n   RFC1123     = \"Mon, 02 Jan 2006 15:04:05 MST\"\n   RFC1123Z    = \"Mon, 02 Jan 2006 15:04:05 -0700\" // RFC1123 with numeric zone\n   RFC3339     = \"2006-01-02T15:04:05Z07:00\"\n   RFC3339Nano = \"2006-01-02T15:04:05.999999999Z07:00\"\n   Kitchen     = \"3:04PM\"\n   // Handy time stamps.\n   Stamp      = \"Jan _2 15:04:05\"\n   StampMilli = \"Jan _2 15:04:05.000\"\n   StampMicro = \"Jan _2 15:04:05.000000\"\n   StampNano  = \"Jan _2 15:04:05.000000000\"\n)\n```\n# 控制结构\n1、这一张其他都很常规，比较有特点的是for。go语言里只有各种各样的for\n```go\nfor i := 1;i < 10; i ++ {}//最常规的\n---\ni := 0\nfor i < 10 {//类似while,另外还有省略3个分号中的某个或者全部，跟他语言类似就不啰嗦了\n\n}\n---\nfor {\n    //什么也不写==死循环 等价于 for ;; 但是格式化的时候会删除;;\n}\n\n-----\n\nfor i,v range some {\n    /*rang 语法类似foreach rang会返回两个值，\n    第一个是序列，第二个是值，这个值一般是值拷贝，\n    如果原来元素里存指针的话这里是指针的拷贝。\n    */\n}\n```\n# 函数\n```go\nfunc change(f...) {//...最后一个参数用。。。表示变长参数，可以传个切片进去  \n//内部用for 遍历参数\n}\n\narr := []int{7,8,9,1}\nchange(arr...)//切片。。。就行了\n```\n\n# 数组和切片\n1、go中数组必须一开始定义好容量，还好有切片（类似动态数组），但是依然没有swift中简单易用。数组在传递给函数或者其他地方的时候是个值拷贝，数组太大的话会比较费内存，所以最好用切片，切片是个引用。一个初始为`nil`的切片定义\n```go\n var s1 []int\n s2 := []int{}\n var s3 []int = make([]int,0)\n s4 := make([]int,0,0)\n //还可以new 一个出来，不过不知道能不能new个空\n```\n空的切片想要追加容量要用 `append()`函数，然后返回一个切片，移除也得用append去模拟实现。切片可以往后切，不能往前切。\n\n> append相关操作\n```go\n\n删除位于索引 i 的元素：a = append(a[:i], a[i+1:]...)\n\n切除切片 a 中从索引 i 至 j 位置的元素：a = append(a[:i], a[j:]...)\n\n为切片 a 扩展 j 个元素长度：a = append(a, make([]T, j)...)\n\n在索引 i 的位置插入元素 x：a = append(a[:i], append([]T{x}, a[i:]...)...)\n\n在索引 i 的位置插入长度为 j 的新切片：a = append(a[:i], append(make([]T, j), a[i:]...)...)\n\n在索引 i 的位置插入切片 b 的所有元素：a = append(a[:i], append(b, a[i:]...)...)\n\n取出位于切片 a 最末尾的元素 x：x, a = a[len(a)-1:], a[:len(a)-1]\n\n将元素 x 追加到切片 a：a = append(a, x)\n\n```\n\n\n2、本章7.2.6中说字符串拼接用bytes.Buffer省内存CPU，其实并没有。我查了一下  go 1.1.0之后加了个strings.Builder 这个才是最好的。但是也要看字符串大小和拼接次数，大多数时候用 `+`其实好，又方便性能也OK","tags":["go"],"categories":["学习"]},{"title":"机场黑名单","url":"/2021/04/29/ssBlankList/","content":"\n\n# 由来\n这篇文章是用来记录我使用过的垃圾机场（翻墙供应商）也让更多的人知道这些黑机场，不能让这些机场收了钱毫无畏惧。\n评价标准包括但不限于经常断流、客服态度差、速度不达标。\n\n大家可以给[shadowBlankList](https://github.com/jokerping/shadowBlankList) 提交issue 或者pr ，提交的时候最好带上原因。  \n\n\n# realnode（以前叫彼岸加速）\n最新官网: realnode.co\n\n> 原因：买之前完全无法看节点内容自称专线加速，买之后发现是AGA根本不是什么专线，这也就算了，速率一直都不达标。经常几十Mbps。有段时间加入BGP后速率达标，但是几天后又开始了，贵且烂。官网工单从不回复。telegram群任何负面反馈马上踢出去加拉黑名单。  \n\n\n\n","tags":["机场"],"categories":["乱七八糟"]}]