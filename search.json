[{"title":"airplay屏幕镜像接收端开发","url":"/2022/08/03/airplay接收端开发/","content":"\n# abstract\n目前网上很多airplay接收端的资料其实并不是屏幕镜像（screen mirroring），而是airplay音频或者其他功能的，airplay是个私有协议，且每个功能点具体协议内容各不相同。我通过实验+查找资料总结了一些经验和坑分享出来。\n\n# 整体流程\nAirPlay服务整体分为两步：\n第一步：接收端通过mDNS发送两个组播服务_airplay._tcp.local 和_raop._tcp.local 其中_raop._tcp.local 广播服务器与客户端交互信息，_airplay._tcp.local广播音视频交互信息和音视频内容。\n第二步：接收端点击屏幕镜像后向_airplay._tcp.local中广播的端口发送RTSP请求，经过多步交互后，再通过apple自有协议发送加密的视频流。此时如果有音频数据传输，会再请求RTSP接口，之后通过RTP协议发送音频数据。\n\n# 服务发现\n## _raop._tcp.local\n此服务作用是接收端告知服务端，在与接收端通信过程所使用的通信[参数细节](https://emanuelecozzi.net/docs/airplay2/discovery/#:~:text=same%20local%20network.-,_raop._tcp.,-RAOP%20stands%20for)，此服务为非必要服务（demo中也没有注册），如果不注册则使用客户端默认参数。\n\n## _airplay._tcp.local\n此服务用于告知客户端，接收端支持的AirPlay功能、服务器信息等。[具体参数](https://openairplay.github.io/airplay-spec/service_discovery.html#_airplay_tcp:~:text=by%20Airplay%20service.-,_airplay._tcp,-name%3A%20Apple%20TV),[参数参考2](https://emanuelecozzi.net/docs/airplay2/discovery/#:~:text=its%20mDNS%20record.-,_airplay._tcp.,-The%20_airplay%20service)，最主要的参数有\n\n`features`：支持的功能，这个值是告知客户端服务端支持哪些功能。不同的features组合会收到不一样的请求，本文仅对屏幕镜像相关在介绍。[具体内容\n](https://openairplay.github.io/airplay-spec/features.html),[参考2](https://emanuelecozzi.net/docs/airplay2/features/)\n\n`model`：设备型号，不同的值会在iPhone上，让接收端显示不同的图标，同时不同设备收到的请求也是不同的，目前尝试只有写AppleTV才有用，且版本不能超过5,3\n\n`flags`：不同flags客户端会发送不同的请求。[具体内容](https://openairplay.github.io/airplay-spec/status_flags.html)\n\n启动服务发现服务后，手机就可以探查当前子网内提供服务的主机，当手机点击连接后，会向MDns广播中提到的地址发送RTSP协议的报文，接下来进入RTSP认证阶段。\n\n# RTSP阶段\n握手阶段使用RTSP1.0协议，接下来的请求按实际请求顺序书写，本阶段的内容仅限于屏幕镜像，其他功能请求流程并不一定一样，请注意。\n\n## GET /info\n客户端没发送什么有用信息给服务端，而是请求了服务端的一些信息，具体内容可参考demo。需要注意的是客户端和服务端交换数据body中需要使用[plist二进制数据](https://en.wikipedia.org/wiki/Property_list)进行传输，需要在header中设置\n\n## POST /pair-setup\n客户端请求服务端的ed25519的public key。在这个请求中，服务端需要根据客户端请求header中的Content-Length生产ed25519的public key，并返回给客户端。同时服务端也需要保存这个key，会在之后的请求中用到。\n\n## POST /pair-verify\n客户端会发送两次该请求，每次发送68个字节，前4个字节位标志位，01 00 00 00 根据第一个字节作为标志位判断后续操作。\n**如果第一个字节是01**\n则将剩余64字节分两组\n- 前32 字节 ecdh_their（curve25519加密对方公钥）\n- 后32 字节 ed_their（ed25519加密对方公钥）\n1、首先使用curve25519算法生成自己的公钥、私钥。同时需要保存，会在后面使用到。\n2、使用从客户端传过来的ecdh_their与自己的生成的私钥生成curve25519的共享秘钥ecdhShared。这个共享秘钥需要保存后面会使用。\n3、使用ed25519算法用 /pair-setup 阶段生成的ed25519私钥进行签名，签名内容为服务器curve25519生成的公钥+客户端curve25519生成的公钥（即前32个字节）得到签名后的结果edSign\n4、使用字符串“Pair-Verify-AES-Key”拼接ecdhShared进行sha512散列，得到散列结果shaKey\n5、使用字符串“Pair-Verify-AES-IV”拼接ecdhShared进行sha512散列，得到散列结果shaIV\n6、使用shaKey和shaIV的前16字节作为AES-CTR-128的key和IV对edSign进行加密。\n7、服务返回96字节，前32字节为服务器生成的curve25519公钥，后64字节为aes加密后的结果。\n\n**如果第1个字节为00**\n则为64个字节全部用作服务端验证客户端签名使用\n1、使用AEC-CTR-128解密得到的64字节内容作为签名进行ed25519验签，其中，公钥为上一步中后32字节，验签内容为上一步中客户端发送的ecdh_their+服务器生成的curve25519公钥\n\n## POST /fp-setup\n客户端会发送两次该请求\n第一次，客户端发送 16 字节请求。第 5 个字节必须是 0x03。第 15 个字节用于了解要使用的“mode”。客户端返回具体的142字节mode，mode具体内容参见demo\n第二次，客户端发送 164 字节请求。第 5 个字节必须是 0x03。需要保存这164字节作呕为KeyMessage用于后面解码视频。\n客户端返回32字节，前 12 个字节是fairplay的header（0x46、0x50、0x4c、0x59、0x03、0x01、0x04、0x00、0x00、0x00、0x00、0x14）其余字节是请求的最后 20 个字节。\n\n## SETUP\n在握手协议之后，会有两个 SETUP 请求用于初始化屏幕镜像。（如果有声音会有第三个）这些SETUP请求并非顺序发生，本文将继续按请求顺序介绍\n第一次，客户端会发送一堆参数过来，具体格式参见demo，有用的有这几个\nekey：AES 密钥\neiv：AES IV\nTimingPort ：用于NTP对时的客户端端口\nTimingProtocol：用于对时的协议\nisScreenMirroringSession：布尔值，用于指示流的类型（仅限视频或音频）\n服务端返回，这里两个参数不确定是在这里返回还是下个SETUP接口返回。\n- eventPort：客户端用来向服务端发送事件的端口\n- TimingPort：客户端用于向服务端对时的接口\n\n## GET_PARAMETER\n客户端查询服务端的一些信息，目前在body播放只有如下内容\"volume\\r\\n\", 镜像设备可以返回给iPhone的body部分为\"volume:0.0\\r\\n\"\n\n## RECORD\n服务端返回head中添加,其中audio 值为请求header的中字段2205的值。如果没有则为0\n```HTML\n\"Audio-Latency\": audio\n```\n\n## SETUP\n**第二次**，在这次请求之前我们需要准备好用于接受音视频数据的服务，如果需要控制、对时，同样要把服务准备好。\n本次请求中客户端发送的有用数据\n- type：流媒体类型\n  - 96：实时音频\n  - 103：缓冲音频\n  - 110：屏幕镜像\n  - 120：播放\n  - 130：遥控器\nstreamConnectionID：当前连接的id,这个ID需要保存，会在后面解密视频时使用到\n服务端需要返回的数据有\n- type：流媒体类型\n  - 96：实时音频\n  - 103：缓冲音频\n  - 110：屏幕镜像\n  - 120：播放\n  - 130：遥控器\n- dataPort：服务端用于接收视频数据的接口\n其余参数和数据结构请参阅demo\n\n## POST /feedback\n客户端进行此调用以确保服务器处于活动状态，该请求的响应必须是没有正文的 200 OK。\n在此之后客户端会向dataPort接口发送视频流，在后面会介绍。\n\n## SETUP\n**第三次**，如果发送的镜像是有声音的，则会受到第三次请求（根据请求的type判断，具体看demo），第三次请求用于设置音频数据相关的内容。详细参数和数据结构见demo，这里只介绍主要的\n这里服务器需要返回一个plist\n```XML\n<plist version=\"1.0\">\n    <dict>\n    <key>streams</key>\n        <array>\n            <dict>\n                <key>dataPort</key> <!--接收音频数据的接口 -->\n                <integer>34505</integer>\n                <key>controlPort</key> <!--音频重传包会通过这个接口给 -->\n                <integer>40945</integer>\n                <key>type</key> <!--数据类型-->\n                <integer>96</integer>\n            </dict>\n        </array>\n    </dict>\n</plist>\n```\n服务端响应此请求后，客户端会开始向dataPort端口发送音频数据，在后面会介绍\n\n# 音视频数据流\n## 视频\n视频流为加密内容，需要首先进行解密然后才能使用。解密步骤为\n1.解密AES密钥，用到fpsetup（CSeq=5）接收到的keymessage。此加密算法为Apple 私有算法非常复杂，请参阅demo中playfair文件夹中的内容。\n2.将解密的desryAesKey和pairing阶段计算出的curve25519 共享密钥进行hash得到eaesHash,方法同pair阶段\n3.使用eaesHash前16个字节与（“AirPlayStreamKey”+setup阶段获得的streamConnectionId）构成的字符串hash方法同上。得到keyHash\n4.同样方法与“AirPlayStreamIv”+streamConnectionId hash得到ivHash\n5.取keyHash和IVhash的前16字节作为key和iv执行aes-ctr-128 解密视频流，视频流是avcc格式的H264裸流\n## 音频\n1.使用视频阶段解密的AESkey（如果没解密这里要做解密）与之前的ecdhShared进行sha512哈希，取前16位做aes的key，使用第一次SETUP阶段收到的eiv作为IV进行AES-CBC-128解密，注意这里是CBC模式。解密后得到AAC裸流。\n\n# 其他请求\n这些请求会在RTSP阶段发送\n## TEARDOWN\n客户端发送关闭请求，服务端需要根据给定type值关闭指定服务。具体业务逻辑可自行设定\n## SET PARAMETER\n客户端在想要更改接收器的音量级别时进行此调用。\n该请求的响应必须是没有正文的 200 OK。\n\n# 补充说明\n## Timing Port\nSETUP阶段设定的对时端口会进行NTP对时通信，使用标准NTP协议，不过多介绍\n## Control Port\n客户端会发送两个可能的值，84和86\n84可以忽略。86是重传的音频数据码，包中会包含音频包\n\n\n# demo地址\ngo实现是本项目的demo，其他两个为参考，其中C实现相对全但是比较复杂。C#更好懂。\n[go实现](https://github.com/jokerping/AirPlay-Mirroring)\n[C实现](https://github.com/FDH2/UxPlay)\n[C#实现](https://github.com/SteeBono/airplayreceiver)\n\n# 参考文献\n[旧一点，很多内容失效，但是字段有参考价值](https://openairplay.github.io/airplay-spec/service_discovery.html)\n[更旧，仅字段有参考价值](https://nto.github.io/AirPlay.html)\n[本文主要参考](https://www.itread01.com/hkeyxif.html)\n","tags":["go","iOS"],"categories":["学习"]},{"title":"减肥","url":"/2022/01/17/weightLoss/","content":"\n之前也断断续续说是减肥，但是总是做“看起来在减肥”的事情，骗自己说我这就是在减肥了。花很多钱报名私教课，做锻炼，但是该吃还是吃。效果有，但是并不明显。想了一下自己的年纪，不想做油腻中年人，索性这次做到底，彻底瘦下来。查了不少资料也结合自己做的事情，总结一下心得。\n\n# 为什么减肥\n- 想多活几年\n- 想找女朋友，女生是不会喜欢个胖子的（或者说瘦子概率大），而且就算有女朋友的，女朋友长得好看而且自己身在难看对女朋友不公平。\n  \n# 怎么做\n- 运动，之前尝试过，我并不想要肌肉而且很累，所以这次我几乎没做什么运动。只是运动而不控制饮食的话效果非常差，运动并没有很多人想的效果那么好，跑半小时可能就是个馒头的热量。如果你只是希望瘦下来，控制饮食就够了，如果还想要好的身材，那运动是必须的。因为在体重减少过程中减少的不止是脂肪，肌肉也会减少\n- 控制饮食，这非常重要。这次找了个知乎赞最多的哈弗食谱，效果很好，但是过程中发现一些问题，这里说一下问题还改进措施\n\n# 原版食谱\n![原来的食谱](https://pic1.zhimg.com/v2-f667ccc48d475ba83475dfdf9351db20_r.jpg?source=1940ef5c)\n\n[怎么样的减肥食谱比较科学？ - 空心果的回答 - 知乎](https://www.zhihu.com/question/19907598/answer/165459340)\n\n首先一些解释\n1、食谱中没说量的地方就是无限，吃多少都行。\n2、食谱中橙子指橙子或者葡萄柚，橙子比较好买而已\n3、食谱1234周之后再用的话是重复两次第一周再重复两次第四周这样循环。\n4、意志力是一种稀缺资源，每个月月底（第4周最后两天）我并按食谱来，而是选择吃我喜欢的东西，每个月吃两天对减肥并没有影响\n\n## 发现的问题&解决办法\n- 食谱中有很多沙拉，首先我不会做（做的不好吃），其次我不爱吃。上班族也没时间弄这些，我全给换成黄瓜了\n- 食谱第一周有两天每天一片面包，但是下次吃面包是第四周，什么面包能放1个月？这对单身且不爱浪费的我造成了非常大的影响。我的办法是，放冰箱里，虽然放了1个月，但是除了干一点并不影响吃（如果你在乎这个，买那种尽可能片数少的，第一周两片后，扔了第四周再买）\n- 食谱早餐是半个橙子，和上个问题一样，谁半个橙子放第二天继续吃？非常影响口感，我选择吃一个\n- 原版食谱第四周是金枪鱼刺身，国内金枪鱼很多假的，我换成了北极贝，后来我发现一样难吃。我在吃完后换成了牛排。\n- 原版鸡胸肉都是无油煎的，我吃不下去换成了[这个做法](https://b23.tv/Zhu7zXl) 鱼我选的是煎带鱼。如果担心过量摄入油，可以吃奥利司他（奥利司他是保健品批号，并不属于药物，安全性没有问题）\n- 原版没有明确说是鸡肉地方我全改成了煎牛排（烤肉、煎肉都是这个，省事好吃）（过程中我还发现，买牛排不一定非要追求原切，我做的并不好吃，原切牛排并没有腌制好的好吃，而且腌制的还便宜。只要能保证这块肉是整块切下来的不是拼接的就行了。）\n- 水煮蔬菜我用的各种蘑菇，我实在吃不下水煮的菜，不放任何调料的话。蘑菇还有点嚼头。\n- 我因为要上班有的时候也懒得做饭。其实食谱中有的地方完全可以做成中国菜，第四周周二，250克鸡肉、3个西红柿，4个黄瓜，2个鸡蛋，1个橙子。完全可以做个西红柿炒鸡蛋或者黄瓜炒鸡蛋之类的。并不会增加多少热量（别放糖）好吃非常多。\n- 原食谱几乎没什么厨艺，就是生吃，吃了很难受。虾和鱼都是水煮，其实没必要。油脂并不会增加多少摄入的（甚至有生酮减肥）担心可以吃奥利司他，虾可以盐焗。没有必要完全按原食谱，只要食材对，不增加其他摄入就OK。最重要的是不要多加餐，饿是正常的。\n\n下面是我自己做了一些修改的，但是并不是所有改动都写在了食谱上。\n\n# 修改版食谱\n\n## 第一周\n![](/images/食谱-第一周.png)\n\n## 第二周\n![](/images/食谱-第二周.png)\n\n## 第三周\n![](/images/食谱-第三周.png)\n\n## 第四周\n![](/images/食谱-第四周.png)\n","tags":["生活"],"categories":["乱七八糟"]},{"title":"go语言学习心得","url":"/2021/05/19/goLang/","content":"\n\n# 序\n在看go的过程中发现了一些比较有意思的点，在swift中是没有的，记一下省的以后找。一些几乎所有语言通用的做法就不写了。目前看的是[the-way-to-go_ZH_CN](https://github.com/unknwon/the-way-to-go_ZH_CN)翻译的还算OK。本文标题也按照书中章节来，但并不是每章都会写。\n\n\n\n# 基本结构和基本数据类型\n1、括号必须和方法一行，声明的局部变量必须使用，引入的包必须使用，否则就给你报错。这点我觉得非常好，让那些异端闭嘴。\n\n2、首字母大写就public 小写就private 非常方便\n\n3、:= 简短声明，在方法内部可以直接这样声明一个新变量d，\b比较省事 `a := 1`\n\n4、声明枚举的时候可以用个常量 `const` ，我看标准库中的枚举会type 一个名字，这样做用来标记个枚举？`iota` 这个关键字比较麻烦，我就不解释了，查一下非常方便。\n> 实际上，类型别名得到的新类型并非和原类型完全相同，新类型不会拥有原类型所附带的方法\n\n```go\ntype Color int\nconst(\n    RED Color = iota\n    YELLOW\n)\n```\n\n5、时间格式化。这简直神经病，不用Y-m-d H:M:S 也就算了，传时间也不是随便传的要用go语言创建时间(2006-01-02 15:04:05 -0700 MST)格式化，比如：\n`time.Now().Format(\"2006-01-02 15:04:05\")`\n当然标准库里定义了一堆常用的\n```go\nconst (\n   ANSIC       = \"Mon Jan _2 15:04:05 2006\"\n   UnixDate    = \"Mon Jan _2 15:04:05 MST 2006\"\n   RubyDate    = \"Mon Jan 02 15:04:05 -0700 2006\"\n   RFC822      = \"02 Jan 06 15:04 MST\"\n   RFC822Z     = \"02 Jan 06 15:04 -0700\" // RFC822 with numeric zone\n   RFC850      = \"Monday, 02-Jan-06 15:04:05 MST\"\n   RFC1123     = \"Mon, 02 Jan 2006 15:04:05 MST\"\n   RFC1123Z    = \"Mon, 02 Jan 2006 15:04:05 -0700\" // RFC1123 with numeric zone\n   RFC3339     = \"2006-01-02T15:04:05Z07:00\"\n   RFC3339Nano = \"2006-01-02T15:04:05.999999999Z07:00\"\n   Kitchen     = \"3:04PM\"\n   // Handy time stamps.\n   Stamp      = \"Jan _2 15:04:05\"\n   StampMilli = \"Jan _2 15:04:05.000\"\n   StampMicro = \"Jan _2 15:04:05.000000\"\n   StampNano  = \"Jan _2 15:04:05.000000000\"\n)\n```\n# 控制结构\n1、这一张其他都很常规，比较有特点的是for。go语言里只有各种各样的for\n```go\nfor i := 1;i < 10; i ++ {}//最常规的\n---\ni := 0\nfor i < 10 {//类似while,另外还有省略3个分号中的某个或者全部，跟他语言类似就不啰嗦了\n\n}\n---\nfor {\n    //什么也不写==死循环 等价于 for ;; 但是格式化的时候会删除;;\n}\n\n-----\n\nfor i,v range some {\n    /*rang 语法类似foreach rang会返回两个值，\n    第一个是序列，第二个是值，这个值一般是值拷贝，\n    如果原来元素里存指针的话这里是指针的拷贝。\n    */\n}\n```\n# 函数\n```go\nfunc change(f...) {//...最后一个参数用。。。表示变长参数，可以传个切片进去  \n//内部用for 遍历参数\n}\n\narr := []int{7,8,9,1}\nchange(arr...)//切片。。。就行了\n```\n\n# 数组和切片\n1、go中数组必须一开始定义好容量，还好有切片（类似动态数组），但是依然没有swift中简单易用。数组在传递给函数或者其他地方的时候是个值拷贝，数组太大的话会比较费内存，所以最好用切片，切片是个引用。一个初始为`nil`的切片定义\n```go\n var s1 []int\n s2 := []int{}\n var s3 []int = make([]int,0)\n s4 := make([]int,0,0)\n //还可以new 一个出来，不过不知道能不能new个空\n```\n空的切片想要追加容量要用 `append()`函数，然后返回一个切片，移除也得用append去模拟实现。切片可以往后切，不能往前切。\n\n> append相关操作\n```go\n\n删除位于索引 i 的元素：a = append(a[:i], a[i+1:]...)\n\n切除切片 a 中从索引 i 至 j 位置的元素：a = append(a[:i], a[j:]...)\n\n为切片 a 扩展 j 个元素长度：a = append(a, make([]T, j)...)\n\n在索引 i 的位置插入元素 x：a = append(a[:i], append([]T{x}, a[i:]...)...)\n\n在索引 i 的位置插入长度为 j 的新切片：a = append(a[:i], append(make([]T, j), a[i:]...)...)\n\n在索引 i 的位置插入切片 b 的所有元素：a = append(a[:i], append(b, a[i:]...)...)\n\n取出位于切片 a 最末尾的元素 x：x, a = a[len(a)-1:], a[:len(a)-1]\n\n将元素 x 追加到切片 a：a = append(a, x)\n\n```\n\n\n2、本章7.2.6中说字符串拼接用bytes.Buffer省内存CPU，其实并没有。我查了一下  go 1.1.0之后加了个strings.Builder 这个才是最好的。但是也要看字符串大小和拼接次数，大多数时候用 `+`其实好，又方便性能也OK\n3、go中的数组可以像字典一样初始化，指定某些下标的值\n```go\nvar arrKeyValue = [5]string{3: \"Chris\", 4: \"Ron\"}\n```\n","tags":["go"],"categories":["学习"]},{"title":"机场黑名单","url":"/2021/04/29/ssBlankList/","content":"\n\n# 由来\n这篇文章是用来记录我使用过的垃圾机场（翻墙供应商）也让更多的人知道这些黑机场，不能让这些机场收了钱毫无畏惧。\n评价标准包括但不限于经常断流、客服态度差、速度不达标。\n\n大家可以给[shadowBlankList](https://github.com/jokerping/shadowBlankList) 提交issue 或者pr ，提交的时候最好带上原因。  \n\n\n# realnode（以前叫彼岸加速）\n最新官网: realnode.co\n\n> 原因：买之前完全无法看节点内容自称专线加速，买之后发现是AGA根本不是什么专线，这也就算了，速率一直都不达标。经常几十Mbps。有段时间加入BGP后速率达标，但是几天后又开始了，贵且烂。官网工单从不回复。telegram群任何负面反馈马上踢出去加拉黑名单。  \n\n\n\n","tags":["机场"],"categories":["乱七八糟"]}]